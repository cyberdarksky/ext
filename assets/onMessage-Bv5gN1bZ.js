function h(a,e){Object.keys(a).map(t=>e(a[t],t,a))}function f(a,e){function t(r,s){switch(r.type){case"object":return n(r,s);case"array":return c(r,s);default:return s!==void 0?s:r.default!==void 0?r.default:void 0}}function n(r,s){const i={},o=r.properties??{};return h(o,(l,u)=>{if(r.required.includes(u)||s!==void 0&&s[u]!==void 0){let p=s!==void 0?s[u]:void 0;!l.properties&&l.default&&l.type==="object"&&l.additionalProperties&&(p=l.default),i[u]=t(l,p)}}),s&&h(s,(l,u)=>{i[u]===void 0&&l!==void 0&&(i[u]=l)}),i}function c(r,s){if(s===void 0)return r.default?r.default:void 0;const i=[];for(let o=0;o<s.length;o++)i.push(t(r.items??{},s[o]));return i}return t(e,a)}const b="__storage-local-version";function A(a){const e=Object.keys(a);chrome.runtime.onInstalled.addListener(n=>{(n.reason==="install"||n.reason==="update")&&t()});async function t(){let n=(await chrome.storage.local.get(b))[b];const c=chrome.runtime.getManifest().version;if(c!==n){const r=await chrome.storage.local.get(e),s=e.reduce((i,o)=>{let l=r[o]||{};return l=f(l,a[o]),i[o]=l,i},{[b]:c});await chrome.storage.local.set(s)}}}function q(a,e){async function t(s){let i;return await navigator.locks.request(d(s),{mode:"shared"},async()=>{i=(await y(s))[s]}),i===void 0&&(i=f(i,a[s])),i}async function n(s,i){await navigator.locks.request(d(s),{mode:"exclusive"},async()=>{let o=(await y(s))[s];o===void 0&&(o=f(o,a[s]));const l=await i(o);await chrome.storage.local.set({[s]:l})})}async function c(s,i){await navigator.locks.request(d(s),{mode:"exclusive"},async()=>{let o=i||{};i||(o=f(o,a[s])),await chrome.storage.local.set({[s]:o})})}async function r(s){return await navigator.locks.request(d(s),{mode:"exclusive"},async()=>{await chrome.storage.local.remove([s])}),Promise.resolve()}return{updateBucket:n,setBucket:c,getBucket:t,deleteBucket:r}}function d(a){return`storage.local.${a}`}function y(a){return new Promise(e=>{chrome.storage.local.get(a,t=>{e(t)})})}function N(){return Math.floor(new Date().getTime()/1e3)}var m=(a=>(a[a.WAITING=0]="WAITING",a[a.RUNNING=1]="RUNNING",a[a.DONE=2]="DONE",a[a.ERROR=3]="ERROR",a))(m||{});const v={type:"array",items:{type:"object",properties:{createAt:{type:"number",default:0},updateAt:{type:"number",default:0},name:{type:"string",default:""},collectionId:{type:"string",default:""},url:{type:"string",default:""},posts:{type:"Array",items:{type:"object",properties:{content:{type:"string",default:""},postId:{type:"string",default:""},link:{type:"string",default:""},status:{type:"number",default:0},log:{type:"string",default:""},genAt:{type:"number",default:0},createAt:{type:"number",default:0}},required:["content","link","postId","status","log","genAt","createAt"]},default:[]}},required:["createAt","updateAt","name","collectionId","url","posts"]},default:[]},w={type:"object",properties:{},required:[],default:{}},R={resumeCursors:w,postsScreenshotArr:v};var k=Object.defineProperty,I=(a,e,t)=>e in a?k(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,g=(a,e,t)=>(I(a,typeof e!="symbol"?e+"":e,t),t);class B{constructor(e,t){g(this,"listeners",{}),g(this,"tabs",[]),g(this,"slug"),g(this,"isDebugger"),this.slug=e,this.isDebugger=!!t,this.bindMessage(),this.bindEvent()}on(e,t){if(this.listeners[e])throw new Error(`event listener ${String(e)} already exist!`);return this.listeners[e]=t,()=>{delete this.listeners[e]}}async send(e,...t){this.isDebugger&&console.log("send message from background script",{action:e,payload:t,tabs:this.tabs});for(let n of this.tabs)try{const c=await chrome.tabs.get(n);c&&c.id?chrome.tabs.sendMessage(c.id,{from:this.slug,payload:{action:e,payload:t}}):this.deleteTabById(n)}catch(c){console.log(c),this.deleteTabById(n)}}bindMessage(){chrome.runtime.onMessageExternal.addListener((e,t,n)=>{var c,r;if((c=t==null?void 0:t.tab)!=null&&c.id){if(this.isDebugger&&console.log("received message from page",{request:e,sender:t}),e.action==="__connect")return this.tabs.includes(t.tab.id)||this.tabs.push(t.tab.id),n();if(e.action==="__disconnect")return this.deleteTabById(t.tab.id),n();if(this.listeners[e.action])return(r=t==null?void 0:t.tab)!=null&&r.id?(this.tabs.includes(t.tab.id)||this.tabs.push(t.tab.id),this.listeners[e.action](...e.payload).then(s=>{this.isDebugger&&console.log("send to callback from background",{request:e,sender:t,res:s}),n(s)}),!0):n();console.log(`unknown event ${e.action}`)}})}bindEvent(){chrome.tabs.onRemoved.addListener(e=>{this.deleteTabById(e)})}deleteTabById(e){if(this.tabs.includes(e)){const t=this.tabs.indexOf(e);this.tabs.splice(t,1)}}}export{R as S,m as a,B as c,N as g,q as p,A as y};
